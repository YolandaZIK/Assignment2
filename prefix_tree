"""CSC148 Assignment 2: Autocompleter classes

=== CSC148 Fall 2018 ===
Department of Computer Science,
University of Toronto

=== Module Description ===
This file contains the design of a public interface (Autocompleter) and two
implementation of this interface, SimplePrefixTree and CompressedPrefixTree.
You'll complete both of these subclasses over the course of this assignment.

As usual, be sure not to change any parts of the given *public interface* in the
starter code---and this includes the instance attributes, which we will be
testing directly! You may, however, add new private attributes, methods, and
top-level functions to this file.
"""
from __future__ import annotations
from typing import Any, List, Optional, Tuple


################################################################################
# The Autocompleter ADT
################################################################################
class Autocompleter:
    """An abstract class representing the Autocompleter Abstract Data Type.
    """
    def __len__(self) -> int:
        """Return the number of values stored in this Autocompleter."""
        raise NotImplementedError

    def insert(self, value: Any, weight: float, prefix: List) -> None:
        """Insert the given value into this Autocompleter.

        The value is inserted with the given weight, and is associated with
        the prefix sequence <prefix>.

        If the value has already been inserted into this prefix tree
        (compare values using ==), then the given weight should be *added* to
        the existing weight of this value.

        Preconditions:
            weight > 0
            The given value is either:
                1) not in this Autocompleter
                2) was previously inserted with the SAME prefix sequence
        """
        raise NotImplementedError

    def autocomplete(self, prefix: List,
                     limit: Optional[int] = None) -> List[Tuple[Any, float]]:
        """Return up to <limit> matches for the given prefix.

        The return value is a list of tuples (value, weight), and must be
        ordered in non-increasing weight. (You can decide how to break ties.)

        If limit is None, return *every* match for the given prefix.

        Precondition: limit is None or limit > 0.
        """
        raise NotImplementedError

    def remove(self, prefix: List) -> None:
        """Remove all values that match the given prefix.
        """
        raise NotImplementedError


################################################################################
# SimplePrefixTree (Tasks 1-3)
################################################################################
class SimplePrefixTree(Autocompleter):
    """A simple prefix tree.

    This class follows the implementation described on the assignment handout.
    Note that we've made the attributes public because we will be accessing them
    directly for testing purposes.

    === Attributes ===
    value:
        The value stored at the root of this prefix tree, or [] if this
        prefix tree is empty.
    weight:
        The weight of this prefix tree. If this tree is a leaf, this attribute
        stores the weight of the value stored in the leaf. If this tree is
        not a leaf and non-empty, this attribute stores the *aggregate weight*
        of the leaf weights in this tree.
    subtrees:
        A list of subtrees of this prefix tree.

    === Representation invariants ===
    - self.weight >= 0

    - (EMPTY TREE):
        If self.weight == 0, then self.value == [] and self.subtrees == [].
        This represents an empty simple prefix tree.
    - (LEAF):
        If self.subtrees == [] and self.weight > 0, this tree is a leaf.
        (self.value is a value that was inserted into this tree.)
    - (NON-EMPTY, NON-LEAF):
        If len(self.subtrees) > 0, then self.value is a list (*common prefix*),
        and self.weight > 0 (*aggregate weight*).

    - ("prefixes grow by 1")
      If len(self.subtrees) > 0, and subtree in self.subtrees, and subtree
      is non-empty and not a leaf, then

          subtree.value == self.value + [x], for some element x

    - self.subtrees does not contain any empty prefix trees.
    - self.subtrees is *sorted* in non-increasing order of their weights.
      (You can break ties any way you like.)
      Note that this applies to both leaves and non-leaf subtrees:
      both can appear in the same self.subtrees list, and both have a `weight`
      attribute.
    """
    value: Any
    weight: float
    subtrees: List[SimplePrefixTree]
    _aggregate_weight: str

    def __init__(self, weight_type: str) -> None:
        """Initialize an empty simple prefix tree.

        Precondition: weight_type == 'sum' or weight_type == 'average'.

        The given <weight_type> value specifies how the aggregate weight
        of non-leaf trees should be calculated (see the assignment handout
        for details).
        """
        self.value = []
        self.weight = 0
        self.subtrees = []
        self._aggregate_weight = weight_type

    def is_empty(self) -> bool:
        """Return whether this simple prefix tree is empty."""
        return self.weight == 0.0

    def is_leaf(self) -> bool:
        """Return whether this simple prefix tree is a leaf."""
        return self.weight > 0 and self.subtrees == []

    def __str__(self) -> str:
        """Return a string representation of this tree.

        You may find this method helpful for debugging.
        """
        return self._str_indented()

    def _str_indented(self, depth: int = 0) -> str:
        """Return an indented string representation of this tree.

        The indentation level is specified by the <depth> parameter.
        """
        if self.is_empty():
            return ''
        else:
            s = '  ' * depth + f'{self.value} ({self.weight})\n'
            for subtree in self.subtrees:
                s += subtree._str_indented(depth + 1)
            return s

    def __len__(self) -> None:
        """Return the number of values stored in this Autocompleter."""
        if self.is_empty():
            return 0
        elif self.is_leaf():
            return 1
        else:
            return sum(subtree.__len__() for subtree in self.subtrees)

    def __contains__(self, value: Any) -> bool:
        """ Return True if the value is already inserted into the tree
        """
        if self.is_empty():
            return False
        elif self.is_leaf():
            return self.value == value
        else:
            for subtree in self.subtrees:
                if value in subtree:
                    return True
            return False

    def _return_all_values(self) -> List[Tuple[Any, float]]:
        """ Return a list of List[value, weight] inserted in the tree
        """
        if self.is_empty():
            return []
        elif self.is_leaf():
            return [(self.value, self.weight)]
        else:
            re = []
            for subtree in self.subtrees:
                re += subtree._return_all_values()
            return sorted(re, key=lambda x: x[1], reverse=True)

    def _insert_on_empty_tree(self, value: Any, weight: float, prefix: List) ->\
            None:

        new_tree = SimplePrefixTree(self._aggregate_weight)
        self.subtrees.append(new_tree)

        if prefix == []:
            new_tree.value, new_tree.weight = value, weight
        else:
            new_tree.value = self.value + [prefix[0]]
            new_tree.insert(value, weight, prefix[1:])
            # new_tree._insert_on_empty_tree(value, weight, prefix[1:])
        self.weight = weight

    def _change_mutated_tree_position(self, mutated_subtree: SimplePrefixTree)\
            -> None:
        """ Append the mutated_subtree at the correct position
            - If the mutated subtree is empty, do not insert this subtree
        """
        if mutated_subtree.is_empty():  # when the mutated_subtree is empty
            return
        elif self.subtrees == []:
            # when there is no subtrees in this simpleprefixtree
            self.subtrees.append(mutated_subtree)
        else:  # when there are subtrees in this simpleprefixtree
            index = 0
            while index < len(self.subtrees):
                if self.subtrees[index].weight < mutated_subtree.weight:
                    break
                index += 1
            self.subtrees.insert(index, mutated_subtree)

    def update_weight(self) -> None:
        """ Update weight of a simple prefix tree
        """
        all_values_inserted = self._return_all_values()
        if len(all_values_inserted) == 0:
            self.weight = 0
        else:
            total_weights = sum(each[1] for each in all_values_inserted)
            if self._aggregate_weight == "sum":
                self.weight = total_weights
            else:
                self.weight = total_weights / len(all_values_inserted)

    def _update_inserted_value(self, value: Any, weight: float, prefix: List) \
            -> None:
        """ Add weight to an inserted value
        """
        if self.is_leaf():
            if self.value == value:
                self.weight += weight
        else:
            found_subtree = None
            index = 0
            while index < len(self.subtrees):
                if value in self.subtrees[index]:
                    found_subtree = self.subtrees[index]
                    break
                else:
                    index += 1
            self.subtrees.pop(index)
            # found_subtree._update_inserted_value(value, weight, prefix)
            found_subtree.insert(value, weight, prefix)
            self._change_mutated_tree_position(found_subtree)
            self.update_weight()

    def _insert_new_value(self, value: Any, weight: float, prefix: List)\
            -> None:
        """ Insert a completely new value on a simple prefix tree.
        """
        if prefix == []:
            new_spt = SimplePrefixTree(self._aggregate_weight)
            new_spt.value, new_spt.weight = value, weight
            self._change_mutated_tree_position(new_spt)
            self.update_weight()
        else:
            new_prefix = True
            index = 0
            while index < len(self.subtrees):
                if self.subtrees[index].is_leaf():
                    index += 1
                else:
                    if self.subtrees[index].value == self.value + [prefix[0]]:
                        new_prefix = False
                        break
                    index += 1

            if new_prefix:
                # print('This is a new prefix')
                new_spt = SimplePrefixTree(self._aggregate_weight)
                new_spt.value = self.value + [prefix[0]]
                new_spt.insert(value, weight, prefix[1:])
                # new_spt._insert_new_value(value, weight, prefix[1:])
                self._change_mutated_tree_position(new_spt)
                # self.update_weight()
            else:  # part of the prefix is in this SimplePrefixTree
                # print('This is part of a prefix in this tree')
                selected_tree = self.subtrees.pop(index)
                selected_tree.insert(value, weight, prefix[1:])
                # selected_tree._insert_new_value(value, weight, prefix[1:])
                self._change_mutated_tree_position(selected_tree)
            self.update_weight()

    def insert(self, value: Any, weight: float, prefix: List) -> None:
        """Insert the given value into this Autocompleter.

        The value is inserted with the given weight, and is associated with
        the prefix sequence <prefix>.

        If the value has already been inserted into this prefix tree
        (compare values using ==), then the given weight should be *added* to
        the existing weight of this value.

        Preconditions:
            weight > 0
            The given value is either:
                1) not in this Autocompleter
                2) was previously inserted with the SAME prefix sequence
        """
        if self.is_empty():
            new_tree = SimplePrefixTree(self._aggregate_weight)
            self.subtrees.append(new_tree)

            if prefix == []:
                new_tree.value, new_tree.weight = value, weight
            else:
                new_tree.value = self.value + [prefix[0]]
                new_tree.insert(value, weight, prefix[1:])
                # new_tree._insert_on_empty_tree(value, weight, prefix[1:])
            self.weight = weight
        else:  # when the tree is not empty
            # Check whether the value is already inserted into the tree
            if value in self:
                # If value is already inserted, do the following:
                #   - add <weight> into the value's weight
                #   - update self.weight
                # print('The value is in this tree')
                if self.is_leaf():
                    if self.value == value:
                        self.weight += weight
                else:
                    found_subtree = None
                    index = 0
                    while index < len(self.subtrees):
                        if value in self.subtrees[index]:
                            found_subtree = self.subtrees[index]
                            break
                        else:
                            index += 1
                    self.subtrees.pop(index)
                    found_subtree.insert(value, weight, prefix)
                    self._change_mutated_tree_position(found_subtree)
                    self.update_weight()
            else:
                # If value is not inserted, do the following:
                #   - insert the value
                #   - update self.weight
                # print('The value is not in this tree')
                # print(prefix)
                if prefix == []:
                    new_spt = SimplePrefixTree(self._aggregate_weight)
                    new_spt.value, new_spt.weight = value, weight
                    self._change_mutated_tree_position(new_spt)
                    self.update_weight()
                else:
                    new_prefix = True
                    index = 0
                    while index < len(self.subtrees):
                        if self.subtrees[index].is_leaf():
                            index += 1
                        else:
                            if self.subtrees[index].value == self.value + [prefix[0]]:
                                new_prefix = False
                                break
                            index += 1

                    if new_prefix:
                        # print('This is a new prefix')
                        new_spt = SimplePrefixTree(self._aggregate_weight)
                        new_spt.value = self.value + [prefix[0]]
                        new_spt.insert(value, weight, prefix[1:])
                        # new_spt._insert_new_value(value, weight, prefix[1:])
                        self._change_mutated_tree_position(new_spt)
                        # self.update_weight()
                    else:  # part of the prefix is in this SimplePrefixTree
                        # print('This is part of a prefix in this tree')
                        selected_tree = self.subtrees.pop(index)
                        selected_tree.insert(value, weight, prefix[1:])
                        self._change_mutated_tree_position(selected_tree)
                    self.update_weight()

    def _prefix_in_tree(self, prefix: List) -> Optional[SimplePrefixTree]:
        """
            Representation invariants: this SimplePrefixTree is not empty.

            If the given prefix is in the tree,
            retrun Tuple[root of the target prefix tree, True]

            If the given prefix is not in the tree,
            return Tuple[None, False]
        """
        if self.is_empty() or self.is_leaf():
            return None
        else:  # this SimplePrefixTree is not empty and not leaf
            if self.value == prefix:
                return self
            else:
                for subtree in self.subtrees:
                    found_prefix_tree = subtree._prefix_in_tree(prefix)
                    if found_prefix_tree is not None:
                        return found_prefix_tree
                return None

    def _return_limit_values(self, limit: int) -> List[Tuple[Any, float]]:
        """ Return values in a SimplePrefixTree.

        Precondition:
        - limit >= 0
        - limit < all values inserted into this SimplePrefixTree
        - limit >= all values inserted into this SimplePrefixTree

        Postcondition:
        - The length of the return list of tuples is <= the total number of
        value inserted in this SimplePrefixTree.

        """
        if self.is_leaf():
            if limit > 0:
                return [(self.value, self.weight)]
            else:
                return []
        else:
            re_values = []
            for subtree in self.subtrees:
                subtree_values = subtree._return_limit_values(limit)
                limit -= len(subtree_values)
                re_values.extend(subtree_values)
            # print(limit)
            return sorted(re_values, key=lambda x: x[1], reverse=True)

    def autocomplete(self, prefix: List,
                     limit: Optional[int] = None) -> List[Tuple[Any, float]]:
        """Return up to <limit> matches for the given prefix.

        The return value is a list of tuples (value, weight), and must be
        ordered in non-increasing weight. (You can decide how to break ties.)

        If limit is None, return *every* match for the given prefix.

        Precondition: limit is None or limit > 0.
        ---------------------------
        # BE CAREFUL ABOUT TIE!
        # When there is only one spot leaft in the accumulator, but two more
        # coming values have the same weight
        """
        # WITHOUT LIMIT
        # Step 1: Check whether the prefix is this SimplePrefixTree
        target_tree = self._prefix_in_tree(prefix)
        if target_tree is None:
            return []
        else:  # the prefix is in this SimplePrefixTree
            if limit is None:
                return target_tree._return_all_values()
            else:
                return target_tree._return_limit_values(limit)

    def remove_empty_subtrees(self) -> None:
        """ Remove all empty trees.
        """
        index = 0
        temp_all_empty_tree = []
        while index < len(self.subtrees):
            current = self.subtrees[index]
            if current.subtrees == []\
                    and current.value == []\
                    and current.weight == 0.0:
                temp_all_empty_tree.append(index)
            index += 1
        for i in temp_all_empty_tree:
            self.subtrees.pop(i)

    def remove(self, prefix: List) -> None:
        """Remove all values that match the given prefix.

        Note: similar to the Tree class, we have a representation invariant that
        says that self.subtrees cannot have any empty prefix trees (i.e., ones
        that do not contain any more values)

        === Representation Invariants ===
        - A simple prefix tree does not contain empty tree

        """
        if self.is_empty():
            return
        if not self.is_leaf() and self.value == prefix:
            self.weight, self.value, self.subtrees = 0.0, [], []
        if self._prefix_in_tree(prefix):
            for subtree in self.subtrees:
                if not subtree.is_leaf() and \
                        subtree.value == prefix[0:len(subtree.value)]:
                    subtree.remove(prefix)
                    subtree.update_weight()

                    if subtree.is_empty():
                        subtree.subtrees, subtree.value = [], []

                    subtree.remove_empty_subtrees()

                    subtree.subtrees.sort(key=lambda x: x.weight, reverse=True)

            self.update_weight()
            self.remove_empty_subtrees()
            self.subtrees.sort(key=lambda x: x.weight, reverse=True)

################################################################################
# CompressedPrefixTree (Task 6)
################################################################################
class CompressedPrefixTree(Autocompleter):
    """A compressed prefix tree implementation.

    While this class has the same public interface as SimplePrefixTree,
    (including the initializer!) this version follows the implementation
    described on Task 6 of the assignment handout, which reduces the number of
    tree objects used to store values in the tree.

    === Attributes ===
    value:
        The value stored at the root of this prefix tree, or [] if this
        prefix tree is empty.
    weight:
        The weight of this prefix tree. If this tree is a leaf, this attribute
        stores the weight of the value stored in the leaf. If this tree is
        not a leaf and non-empty, this attribute stores the *aggregate weight*
        of the leaf weights in this tree.
    subtrees:
        A list of subtrees of this prefix tree.

    === Representation invariants ===
    - self.weight >= 0

    - (EMPTY TREE):
        If self.weight == 0, then self.value == [] and self.subtrees == [].
        This represents an empty simple prefix tree.
    - (LEAF):
        If self.subtrees == [] and self.weight > 0, this tree is a leaf.
        (self.value is a value that was inserted into this tree.)
    - (NON-EMPTY, NON-LEAF):
        If len(self.subtrees) > 0, then self.value is a list (*common prefix*),
        and self.weight > 0 (*aggregate weight*).

    - **NEW**
      This tree does not contain any compressible internal values.
      (See the assignment handout for a definition of "compressible".)

    - self.subtrees does not contain any empty prefix trees.
    - self.subtrees is *sorted* in non-increasing order of their weights.
      (You can break ties any way you like.)
      Note that this applies to both leaves and non-leaf subtrees:
      both can appear in the same self.subtrees list, and both have a `weight`
      attribute.
    """
    value: Optional[Any]
    weight: float
    subtrees: List[CompressedPrefixTree]


if __name__ == '__main__':
    import python_ta
    python_ta.check_all(config={
        'max-nested-blocks': 4
    })